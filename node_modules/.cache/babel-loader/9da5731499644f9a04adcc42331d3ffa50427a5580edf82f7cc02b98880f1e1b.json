{"ast":null,"code":"/** @license React v16.5.0\n * schedule.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n    /**\n     * A scheduling library to allow scheduling work with more granular priority and\n     * control than requestAnimationFrame and requestIdleCallback.\n     * Current TODO items:\n     * X- Pull out the scheduleWork polyfill built into React\n     * X- Initial test coverage\n     * X- Support for multiple callbacks\n     * - Support for two priorities; serial and deferred\n     * - Better test coverage\n     * - Better docblock\n     * - Polish documentation, API\n     */\n\n    // This is a built-in polyfill for requestIdleCallback. It works by scheduling\n    // a requestAnimationFrame, storing the time for the start of the frame, then\n    // scheduling a postMessage which gets scheduled after paint. Within the\n    // postMessage handler do as much work as possible until time + frame rate.\n    // By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated.\n    // We want to be using a consistent implementation.\n    var localDate = Date;\n\n    // This initialization code may run even on server environments\n    // if a component just imports ReactDOM (e.g. for findDOMNode).\n    // Some environments might not have setTimeout or clearTimeout.\n    // However, we always expect them to be defined on the client.\n    // https://github.com/facebook/react/pull/13088\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n    // We don't expect either of these to necessarily be defined,\n    // but we will error later if they are missing on the client.\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    exports.unstable_now = void 0;\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n    exports.unstable_scheduleWork = void 0;\n    exports.unstable_cancelScheduledWork = void 0;\n    if (!canUseDOM) {\n      var timeoutIds = new Map();\n      exports.unstable_scheduleWork = function (callback, options) {\n        // keeping return type consistent\n        var callbackConfig = {\n          scheduledCallback: callback,\n          timeoutTime: 0,\n          next: null,\n          prev: null\n        };\n        var timeoutId = localSetTimeout(function () {\n          callback({\n            timeRemaining: function () {\n              return Infinity;\n            },\n            didTimeout: false\n          });\n        });\n        timeoutIds.set(callback, timeoutId);\n        return callbackConfig;\n      };\n      exports.unstable_cancelScheduledWork = function (callbackId) {\n        var callback = callbackId.scheduledCallback;\n        var timeoutId = timeoutIds.get(callback);\n        timeoutIds.delete(callbackId);\n        localClearTimeout(timeoutId);\n      };\n    } else {\n      {\n        if (typeof console !== 'undefined') {\n          if (typeof localRequestAnimationFrame !== 'function') {\n            console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n          }\n          if (typeof localCancelAnimationFrame !== 'function') {\n            console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n          }\n        }\n      }\n      var headOfPendingCallbacksLinkedList = null;\n      var tailOfPendingCallbacksLinkedList = null;\n\n      // We track what the next soonest timeoutTime is, to be able to quickly tell\n      // if none of the scheduled callbacks have timed out.\n      var nextSoonestTimeoutTime = -1;\n      var isIdleScheduled = false;\n      var isAnimationFrameScheduled = false;\n\n      // requestAnimationFrame does not run when the tab is in the background.\n      // if we're backgrounded we prefer for that work to happen so that the page\n      // continues\tto load in the background.\n      // so we also schedule a 'setTimeout' as a fallback.\n      var animationFrameTimeout = 100;\n      var rafID = void 0;\n      var timeoutID = void 0;\n      var scheduleAnimationFrameWithFallbackSupport = function (callback) {\n        // schedule rAF and also a setTimeout\n        rafID = localRequestAnimationFrame(function (timestamp) {\n          // cancel the setTimeout\n          localClearTimeout(timeoutID);\n          callback(timestamp);\n        });\n        timeoutID = localSetTimeout(function () {\n          // cancel the requestAnimationFrame\n          localCancelAnimationFrame(rafID);\n          callback(exports.unstable_now());\n        }, animationFrameTimeout);\n      };\n      var frameDeadline = 0;\n      // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      var frameDeadlineObject = {\n        didTimeout: false,\n        timeRemaining: function () {\n          var remaining = frameDeadline - exports.unstable_now();\n          return remaining > 0 ? remaining : 0;\n        }\n      };\n\n      /**\n       * Handles the case where a callback errors:\n       * - don't catch the error, because this changes debugging behavior\n       * - do start a new postMessage callback, to call any remaining callbacks,\n       * - but only if there is an error, so there is not extra overhead.\n       */\n      var callUnsafely = function (callbackConfig, arg) {\n        var callback = callbackConfig.scheduledCallback;\n        var finishedCalling = false;\n        try {\n          callback(arg);\n          finishedCalling = true;\n        } finally {\n          // always remove it from linked list\n          exports.unstable_cancelScheduledWork(callbackConfig);\n          if (!finishedCalling) {\n            // an error must have been thrown\n            isIdleScheduled = true;\n            window.postMessage(messageKey, '*');\n          }\n        }\n      };\n\n      /**\n       * Checks for timed out callbacks, runs them, and then checks again to see if\n       * any more have timed out.\n       * Keeps doing this until there are none which have currently timed out.\n       */\n      var callTimedOutCallbacks = function () {\n        if (headOfPendingCallbacksLinkedList === null) {\n          return;\n        }\n        var currentTime = exports.unstable_now();\n        // TODO: this would be more efficient if deferred callbacks are stored in\n        // min heap.\n        // Or in a linked list with links for both timeoutTime order and insertion\n        // order.\n        // For now an easy compromise is the current approach:\n        // Keep a pointer to the soonest timeoutTime, and check that first.\n        // If it has not expired, we can skip traversing the whole list.\n        // If it has expired, then we step through all the callbacks.\n        if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {\n          // We know that none of them have timed out yet.\n          return;\n        }\n        // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n        // after successfully calling any timed out callbacks.\n        // If a timed out callback throws an error, we could get stuck in a state\n        // where the nextSoonestTimeoutTime was set wrong.\n        var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below\n        var timedOutCallbacks = [];\n\n        // iterate once to find timed out callbacks and find nextSoonestTimeoutTime\n        var currentCallbackConfig = headOfPendingCallbacksLinkedList;\n        while (currentCallbackConfig !== null) {\n          var _timeoutTime = currentCallbackConfig.timeoutTime;\n          if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {\n            // it has timed out!\n            timedOutCallbacks.push(currentCallbackConfig);\n          } else {\n            if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {\n              updatedNextSoonestTimeoutTime = _timeoutTime;\n            }\n          }\n          currentCallbackConfig = currentCallbackConfig.next;\n        }\n        if (timedOutCallbacks.length > 0) {\n          frameDeadlineObject.didTimeout = true;\n          for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {\n            callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n          }\n        }\n\n        // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n        // after successfully calling any timed out callbacks.\n        nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;\n      };\n\n      // We use the postMessage trick to defer idle work until after the repaint.\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n      var idleTick = function (event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n        isIdleScheduled = false;\n        if (headOfPendingCallbacksLinkedList === null) {\n          return;\n        }\n\n        // First call anything which has timed out, until we have caught up.\n        callTimedOutCallbacks();\n        var currentTime = exports.unstable_now();\n        // Next, as long as we have idle time, try calling more callbacks.\n        while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {\n          var latestCallbackConfig = headOfPendingCallbacksLinkedList;\n          frameDeadlineObject.didTimeout = false;\n          // callUnsafely will remove it from the head of the linked list\n          callUnsafely(latestCallbackConfig, frameDeadlineObject);\n          currentTime = exports.unstable_now();\n        }\n        if (headOfPendingCallbacksLinkedList !== null) {\n          if (!isAnimationFrameScheduled) {\n            // Schedule another animation callback so we retry later.\n            isAnimationFrameScheduled = true;\n            scheduleAnimationFrameWithFallbackSupport(animationTick);\n          }\n        }\n      };\n      // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n      window.addEventListener('message', idleTick, false);\n      var animationTick = function (rafTime) {\n        isAnimationFrameScheduled = false;\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If we get lower than that, it is probably a bug.\n            nextFrameTime = 8;\n          }\n          // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n        frameDeadline = rafTime + activeFrameTime;\n        if (!isIdleScheduled) {\n          isIdleScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n      exports.unstable_scheduleWork = function (callback, options) /* CallbackConfigType */{\n        var timeoutTime = -1;\n        if (options != null && typeof options.timeout === 'number') {\n          timeoutTime = exports.unstable_now() + options.timeout;\n        }\n        if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {\n          nextSoonestTimeoutTime = timeoutTime;\n        }\n        var scheduledCallbackConfig = {\n          scheduledCallback: callback,\n          timeoutTime: timeoutTime,\n          prev: null,\n          next: null\n        };\n        if (headOfPendingCallbacksLinkedList === null) {\n          // Make this callback the head and tail of our list\n          headOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n          tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n        } else {\n          // Add latest callback as the new tail of the list\n          scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList;\n          // renaming for clarity\n          var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;\n          if (oldTailOfPendingCallbacksLinkedList !== null) {\n            oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;\n          }\n          tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n        }\n        if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger scheduleWork as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          scheduleAnimationFrameWithFallbackSupport(animationTick);\n        }\n        return scheduledCallbackConfig;\n      };\n      exports.unstable_cancelScheduledWork = function (callbackConfig /* CallbackConfigType */) {\n        if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {\n          // this callbackConfig has already been cancelled.\n          // cancelScheduledWork should be idempotent, a no-op after first call.\n          return;\n        }\n\n        /**\n         * There are four possible cases:\n         * - Head/nodeToRemove/Tail -> null\n         *   In this case we set Head and Tail to null.\n         * - Head -> ... middle nodes... -> Tail/nodeToRemove\n         *   In this case we point the middle.next to null and put middle as the new\n         *   Tail.\n         * - Head/nodeToRemove -> ...middle nodes... -> Tail\n         *   In this case we point the middle.prev at null and move the Head to\n         *   middle.\n         * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n         *   In this case we point the Head.next to the Tail and the Tail.prev to\n         *   the Head.\n         */\n        var next = callbackConfig.next;\n        var prev = callbackConfig.prev;\n        callbackConfig.next = null;\n        callbackConfig.prev = null;\n        if (next !== null) {\n          // we have a next\n\n          if (prev !== null) {\n            // we have a prev\n\n            // callbackConfig is somewhere in the middle of a list of 3 or more nodes.\n            prev.next = next;\n            next.prev = prev;\n            return;\n          } else {\n            // there is a next but not a previous one;\n            // callbackConfig is the head of a list of 2 or more other nodes.\n            next.prev = null;\n            headOfPendingCallbacksLinkedList = next;\n            return;\n          }\n        } else {\n          // there is no next callback config; this must the tail of the list\n\n          if (prev !== null) {\n            // we have a prev\n\n            // callbackConfig is the tail of a list of 2 or more other nodes.\n            prev.next = null;\n            tailOfPendingCallbacksLinkedList = prev;\n            return;\n          } else {\n            // there is no previous callback config;\n            // callbackConfig is the only thing in the linked list,\n            // so both head and tail point to it.\n            headOfPendingCallbacksLinkedList = null;\n            tailOfPendingCallbacksLinkedList = null;\n            return;\n          }\n        }\n      };\n    }\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","canUseDOM","window","document","createElement","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","hasNativePerformanceNow","performance","now","unstable_now","Performance","unstable_scheduleWork","unstable_cancelScheduledWork","timeoutIds","Map","callback","options","callbackConfig","scheduledCallback","timeoutTime","next","prev","timeoutId","timeRemaining","Infinity","didTimeout","set","callbackId","get","delete","console","error","headOfPendingCallbacksLinkedList","tailOfPendingCallbacksLinkedList","nextSoonestTimeoutTime","isIdleScheduled","isAnimationFrameScheduled","animationFrameTimeout","rafID","timeoutID","scheduleAnimationFrameWithFallbackSupport","timestamp","frameDeadline","previousFrameTime","activeFrameTime","frameDeadlineObject","remaining","callUnsafely","arg","finishedCalling","postMessage","messageKey","callTimedOutCallbacks","currentTime","updatedNextSoonestTimeoutTime","timedOutCallbacks","currentCallbackConfig","_timeoutTime","push","length","i","len","Math","random","toString","slice","idleTick","event","source","data","latestCallbackConfig","animationTick","addEventListener","rafTime","nextFrameTime","timeout","scheduledCallbackConfig","oldTailOfPendingCallbacksLinkedList"],"sources":["/Users/mike/Projects/react-conversational-form-example-bgnaje/node_modules/schedule/cjs/schedule.development.js"],"sourcesContent":["/** @license React v16.5.0\n * schedule.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * A scheduling library to allow scheduling work with more granular priority and\n * control than requestAnimationFrame and requestIdleCallback.\n * Current TODO items:\n * X- Pull out the scheduleWork polyfill built into React\n * X- Initial test coverage\n * X- Support for multiple callbacks\n * - Support for two priorities; serial and deferred\n * - Better test coverage\n * - Better docblock\n * - Polish documentation, API\n */\n\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated.\n// We want to be using a consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n// However, we always expect them to be defined on the client.\n// https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined,\n// but we will error later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nexports.unstable_now = void 0;\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nexports.unstable_scheduleWork = void 0;\nexports.unstable_cancelScheduledWork = void 0;\n\nif (!canUseDOM) {\n  var timeoutIds = new Map();\n\n  exports.unstable_scheduleWork = function (callback, options) {\n    // keeping return type consistent\n    var callbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: 0,\n      next: null,\n      prev: null\n    };\n    var timeoutId = localSetTimeout(function () {\n      callback({\n        timeRemaining: function () {\n          return Infinity;\n        },\n\n        didTimeout: false\n      });\n    });\n    timeoutIds.set(callback, timeoutId);\n    return callbackConfig;\n  };\n  exports.unstable_cancelScheduledWork = function (callbackId) {\n    var callback = callbackId.scheduledCallback;\n    var timeoutId = timeoutIds.get(callback);\n    timeoutIds.delete(callbackId);\n    localClearTimeout(timeoutId);\n  };\n} else {\n  {\n    if (typeof console !== 'undefined') {\n      if (typeof localRequestAnimationFrame !== 'function') {\n        console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n      }\n      if (typeof localCancelAnimationFrame !== 'function') {\n        console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n      }\n    }\n  }\n\n  var headOfPendingCallbacksLinkedList = null;\n  var tailOfPendingCallbacksLinkedList = null;\n\n  // We track what the next soonest timeoutTime is, to be able to quickly tell\n  // if none of the scheduled callbacks have timed out.\n  var nextSoonestTimeoutTime = -1;\n\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n\n  // requestAnimationFrame does not run when the tab is in the background.\n  // if we're backgrounded we prefer for that work to happen so that the page\n  // continues\tto load in the background.\n  // so we also schedule a 'setTimeout' as a fallback.\n  var animationFrameTimeout = 100;\n  var rafID = void 0;\n  var timeoutID = void 0;\n  var scheduleAnimationFrameWithFallbackSupport = function (callback) {\n    // schedule rAF and also a setTimeout\n    rafID = localRequestAnimationFrame(function (timestamp) {\n      // cancel the setTimeout\n      localClearTimeout(timeoutID);\n      callback(timestamp);\n    });\n    timeoutID = localSetTimeout(function () {\n      // cancel the requestAnimationFrame\n      localCancelAnimationFrame(rafID);\n      callback(exports.unstable_now());\n    }, animationFrameTimeout);\n  };\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject = {\n    didTimeout: false,\n    timeRemaining: function () {\n      var remaining = frameDeadline - exports.unstable_now();\n      return remaining > 0 ? remaining : 0;\n    }\n  };\n\n  /**\n   * Handles the case where a callback errors:\n   * - don't catch the error, because this changes debugging behavior\n   * - do start a new postMessage callback, to call any remaining callbacks,\n   * - but only if there is an error, so there is not extra overhead.\n   */\n  var callUnsafely = function (callbackConfig, arg) {\n    var callback = callbackConfig.scheduledCallback;\n    var finishedCalling = false;\n    try {\n      callback(arg);\n      finishedCalling = true;\n    } finally {\n      // always remove it from linked list\n      exports.unstable_cancelScheduledWork(callbackConfig);\n\n      if (!finishedCalling) {\n        // an error must have been thrown\n        isIdleScheduled = true;\n        window.postMessage(messageKey, '*');\n      }\n    }\n  };\n\n  /**\n   * Checks for timed out callbacks, runs them, and then checks again to see if\n   * any more have timed out.\n   * Keeps doing this until there are none which have currently timed out.\n   */\n  var callTimedOutCallbacks = function () {\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    var currentTime = exports.unstable_now();\n    // TODO: this would be more efficient if deferred callbacks are stored in\n    // min heap.\n    // Or in a linked list with links for both timeoutTime order and insertion\n    // order.\n    // For now an easy compromise is the current approach:\n    // Keep a pointer to the soonest timeoutTime, and check that first.\n    // If it has not expired, we can skip traversing the whole list.\n    // If it has expired, then we step through all the callbacks.\n    if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {\n      // We know that none of them have timed out yet.\n      return;\n    }\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    // If a timed out callback throws an error, we could get stuck in a state\n    // where the nextSoonestTimeoutTime was set wrong.\n    var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below\n    var timedOutCallbacks = [];\n\n    // iterate once to find timed out callbacks and find nextSoonestTimeoutTime\n    var currentCallbackConfig = headOfPendingCallbacksLinkedList;\n    while (currentCallbackConfig !== null) {\n      var _timeoutTime = currentCallbackConfig.timeoutTime;\n      if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {\n        // it has timed out!\n        timedOutCallbacks.push(currentCallbackConfig);\n      } else {\n        if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {\n          updatedNextSoonestTimeoutTime = _timeoutTime;\n        }\n      }\n      currentCallbackConfig = currentCallbackConfig.next;\n    }\n\n    if (timedOutCallbacks.length > 0) {\n      frameDeadlineObject.didTimeout = true;\n      for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {\n        callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n      }\n    }\n\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n    isIdleScheduled = false;\n\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    // First call anything which has timed out, until we have caught up.\n    callTimedOutCallbacks();\n\n    var currentTime = exports.unstable_now();\n    // Next, as long as we have idle time, try calling more callbacks.\n    while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {\n      var latestCallbackConfig = headOfPendingCallbacksLinkedList;\n      frameDeadlineObject.didTimeout = false;\n      // callUnsafely will remove it from the head of the linked list\n      callUnsafely(latestCallbackConfig, frameDeadlineObject);\n      currentTime = exports.unstable_now();\n    }\n    if (headOfPendingCallbacksLinkedList !== null) {\n      if (!isAnimationFrameScheduled) {\n        // Schedule another animation callback so we retry later.\n        isAnimationFrameScheduled = true;\n        scheduleAnimationFrameWithFallbackSupport(animationTick);\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  exports.unstable_scheduleWork = function (callback, options) /* CallbackConfigType */{\n    var timeoutTime = -1;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = exports.unstable_now() + options.timeout;\n    }\n    if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {\n      nextSoonestTimeoutTime = timeoutTime;\n    }\n\n    var scheduledCallbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: timeoutTime,\n      prev: null,\n      next: null\n    };\n    if (headOfPendingCallbacksLinkedList === null) {\n      // Make this callback the head and tail of our list\n      headOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    } else {\n      // Add latest callback as the new tail of the list\n      scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList;\n      // renaming for clarity\n      var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;\n      if (oldTailOfPendingCallbacksLinkedList !== null) {\n        oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;\n      }\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    }\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger scheduleWork as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      scheduleAnimationFrameWithFallbackSupport(animationTick);\n    }\n    return scheduledCallbackConfig;\n  };\n\n  exports.unstable_cancelScheduledWork = function (callbackConfig /* CallbackConfigType */\n  ) {\n    if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {\n      // this callbackConfig has already been cancelled.\n      // cancelScheduledWork should be idempotent, a no-op after first call.\n      return;\n    }\n\n    /**\n     * There are four possible cases:\n     * - Head/nodeToRemove/Tail -> null\n     *   In this case we set Head and Tail to null.\n     * - Head -> ... middle nodes... -> Tail/nodeToRemove\n     *   In this case we point the middle.next to null and put middle as the new\n     *   Tail.\n     * - Head/nodeToRemove -> ...middle nodes... -> Tail\n     *   In this case we point the middle.prev at null and move the Head to\n     *   middle.\n     * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n     *   In this case we point the Head.next to the Tail and the Tail.prev to\n     *   the Head.\n     */\n    var next = callbackConfig.next;\n    var prev = callbackConfig.prev;\n    callbackConfig.next = null;\n    callbackConfig.prev = null;\n    if (next !== null) {\n      // we have a next\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is somewhere in the middle of a list of 3 or more nodes.\n        prev.next = next;\n        next.prev = prev;\n        return;\n      } else {\n        // there is a next but not a previous one;\n        // callbackConfig is the head of a list of 2 or more other nodes.\n        next.prev = null;\n        headOfPendingCallbacksLinkedList = next;\n        return;\n      }\n    } else {\n      // there is no next callback config; this must the tail of the list\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is the tail of a list of 2 or more other nodes.\n        prev.next = null;\n        tailOfPendingCallbacksLinkedList = prev;\n        return;\n      } else {\n        // there is no previous callback config;\n        // callbackConfig is the only thing in the linked list,\n        // so both head and tail point to it.\n        headOfPendingCallbacksLinkedList = null;\n        tailOfPendingCallbacksLinkedList = null;\n        return;\n      }\n    }\n  };\n}\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}